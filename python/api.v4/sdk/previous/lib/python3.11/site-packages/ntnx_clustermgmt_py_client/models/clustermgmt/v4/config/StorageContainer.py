# coding: utf-8


"""
IGNORE:
    Nutanix Cluster Management APIs

    Manage Hosts, Clusters and other Infrastructure.  # noqa: E501

    OpenAPI spec version: 4.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.CacheDeduplication import CacheDeduplication  # noqa: F401,E501
from ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ErasureCodeStatus import ErasureCodeStatus  # noqa: F401,E501
from ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.OnDiskDedup import OnDiskDedup  # noqa: F401,E501
from ntnx_clustermgmt_py_client.models.common.v1.config.IPAddressOrFQDN import IPAddressOrFQDN  # noqa: F401,E501
from ntnx_clustermgmt_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_clustermgmt_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501

class StorageContainer(ExternalizableAbstractModel):

    """

    :param container_ext_id: (:attr:`container_ext_id`) The external identifier of the Storage Container.
    :type container_ext_id: 
    
    
    :param owner_ext_id: (:attr:`owner_ext_id`) The external identifier of the owner.
    :type owner_ext_id: 
    
    
    :param name: (:attr:`name`) Name of the Storage Container. Note that the name of Storage Container should be unique in every cluster.
    :type name: required
     max=75 chars
    
    :param cluster_ext_id: (:attr:`cluster_ext_id`) The external identifier of the cluster owning the Storage Container.
    :type cluster_ext_id: 
    
    
    :param storage_pool_ext_id: (:attr:`storage_pool_ext_id`) The external identifier  of the Storage Pool owning the Storage Container instance.
    :type storage_pool_ext_id: 
    
    
    :param is_marked_for_removal: (:attr:`is_marked_for_removal`) Indicates whether the Storage Container is marked for removal. This field is set when the Storage Container is about to be destroyed.
    :type is_marked_for_removal: 
    
    
    :param max_capacity_bytes: (:attr:`max_capacity_bytes`) Maximum physical capacity of the Storage Container in bytes.
    :type max_capacity_bytes: 
    
    
    :param logical_explicit_reserved_capacity_bytes: (:attr:`logical_explicit_reserved_capacity_bytes`) Total reserved size (in bytes) of the Storage Container (set by Admin). This also includes the replication factor of the Storage Container. The actual reserved capacity of the Storage Container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.
    :type logical_explicit_reserved_capacity_bytes: 
    
    
    :param logical_implicit_reserved_capacity_bytes: (:attr:`logical_implicit_reserved_capacity_bytes`) This is the sum of the  of reservations provisioned on all vDisks in the Storage Container. The actual reserved capacity of the Storage Container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.
    :type logical_implicit_reserved_capacity_bytes: 
    
    
    :param logical_advertised_capacity_bytes: (:attr:`logical_advertised_capacity_bytes`) Maximum capacity of the Storage Container as defined by the user.
    :type logical_advertised_capacity_bytes: 
    
    
    :param replication_factor: (:attr:`replication_factor`) Replication factor of the Storage Container.
    :type replication_factor: 
    
    
    :param nfs_whitelist_address: (:attr:`nfs_whitelist_address`) List of NFS addresses that need to be whitelisted.
    :type nfs_whitelist_address: 
    
    
    :param is_nfs_whitelist_inherited: (:attr:`is_nfs_whitelist_inherited`) Indicates whether the NFS whitelist is inherited from the global configuration.
    :type is_nfs_whitelist_inherited: 
    
    
    :param erasure_code: (:attr:`erasure_code`) 
    :type erasure_code: 
    
    
    :param is_inline_ec_enabled: (:attr:`is_inline_ec_enabled`) Indicates whether data written to this Storage Container should be inline erasure-coded or not. This field is only considered if ErasureCoding is enabled.
    :type is_inline_ec_enabled: 
    
    
    :param has_higher_ec_fault_domain_preference: (:attr:`has_higher_ec_fault_domain_preference`) Indicates whether to prefer a higher Erasure Code fault domain.
    :type has_higher_ec_fault_domain_preference: 
    
    
    :param erasure_code_delay_secs: (:attr:`erasure_code_delay_secs`) Delay in performing Erasure Code for the current Storage Container instance.
    :type erasure_code_delay_secs: 
    
    
    :param cache_deduplication: (:attr:`cache_deduplication`) 
    :type cache_deduplication: 
    
    
    :param on_disk_dedup: (:attr:`on_disk_dedup`) 
    :type on_disk_dedup: 
    
    
    :param is_compression_enabled: (:attr:`is_compression_enabled`) Indicates whether the compression is enabled for the Storage Container.
    :type is_compression_enabled: 
    
    
    :param compression_delay_secs: (:attr:`compression_delay_secs`) The compression delay in seconds.
    :type compression_delay_secs: 
    
    
    :param is_internal: (:attr:`is_internal`) Indicates whether the Storage Container is internal and is managed by Nutanix.
    :type is_internal: 
    
    
    :param is_software_encryption_enabled: (:attr:`is_software_encryption_enabled`) Indicates whether the Storage Container instance has software encryption enabled.
    :type is_software_encryption_enabled: 
    
    
    :param is_encrypted: (:attr:`is_encrypted`) Indicates whether the Storage Container is encrypted or not.
    :type is_encrypted: 
    
    
    :param affinity_host_ext_id: (:attr:`affinity_host_ext_id`) Affinity host external identifier for RF-1 Storage Container.
    :type affinity_host_ext_id: 
    
    
    :param cluster_name: (:attr:`cluster_name`) The corresponding name of the cluster owning the Storage Container instance.
    :type cluster_name: 
     max=256 chars
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'container_ext_id': 'str',
        'owner_ext_id': 'str',
        'name': 'str',
        'cluster_ext_id': 'str',
        'storage_pool_ext_id': 'str',
        'is_marked_for_removal': 'bool',
        'max_capacity_bytes': 'int',
        'logical_explicit_reserved_capacity_bytes': 'int',
        'logical_implicit_reserved_capacity_bytes': 'int',
        'logical_advertised_capacity_bytes': 'int',
        'replication_factor': 'int',
        'nfs_whitelist_address': 'list[common.v1.config.IPAddressOrFQDN]',
        'is_nfs_whitelist_inherited': 'bool',
        'erasure_code': 'clustermgmt.v4.config.ErasureCodeStatus',
        'is_inline_ec_enabled': 'bool',
        'has_higher_ec_fault_domain_preference': 'bool',
        'erasure_code_delay_secs': 'int',
        'cache_deduplication': 'clustermgmt.v4.config.CacheDeduplication',
        'on_disk_dedup': 'clustermgmt.v4.config.OnDiskDedup',
        'is_compression_enabled': 'bool',
        'compression_delay_secs': 'int',
        'is_internal': 'bool',
        'is_software_encryption_enabled': 'bool',
        'is_encrypted': 'bool',
        'affinity_host_ext_id': 'str',
        'cluster_name': 'str',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'container_ext_id': 'containerExtId',
        'owner_ext_id': 'ownerExtId',
        'name': 'name',
        'cluster_ext_id': 'clusterExtId',
        'storage_pool_ext_id': 'storagePoolExtId',
        'is_marked_for_removal': 'isMarkedForRemoval',
        'max_capacity_bytes': 'maxCapacityBytes',
        'logical_explicit_reserved_capacity_bytes': 'logicalExplicitReservedCapacityBytes',
        'logical_implicit_reserved_capacity_bytes': 'logicalImplicitReservedCapacityBytes',
        'logical_advertised_capacity_bytes': 'logicalAdvertisedCapacityBytes',
        'replication_factor': 'replicationFactor',
        'nfs_whitelist_address': 'nfsWhitelistAddress',
        'is_nfs_whitelist_inherited': 'isNfsWhitelistInherited',
        'erasure_code': 'erasureCode',
        'is_inline_ec_enabled': 'isInlineEcEnabled',
        'has_higher_ec_fault_domain_preference': 'hasHigherEcFaultDomainPreference',
        'erasure_code_delay_secs': 'erasureCodeDelaySecs',
        'cache_deduplication': 'cacheDeduplication',
        'on_disk_dedup': 'onDiskDedup',
        'is_compression_enabled': 'isCompressionEnabled',
        'compression_delay_secs': 'compressionDelaySecs',
        'is_internal': 'isInternal',
        'is_software_encryption_enabled': 'isSoftwareEncryptionEnabled',
        'is_encrypted': 'isEncrypted',
        'affinity_host_ext_id': 'affinityHostExtId',
        'cluster_name': 'clusterName',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, container_ext_id=None, owner_ext_id=None, name=None, cluster_ext_id=None, storage_pool_ext_id=None, is_marked_for_removal=None, max_capacity_bytes=None, logical_explicit_reserved_capacity_bytes=None, logical_implicit_reserved_capacity_bytes=None, logical_advertised_capacity_bytes=None, replication_factor=None, nfs_whitelist_address=None, is_nfs_whitelist_inherited=None, erasure_code=None, is_inline_ec_enabled=None, has_higher_ec_fault_domain_preference=None, erasure_code_delay_secs=None, cache_deduplication=None, on_disk_dedup=None, is_compression_enabled=None, compression_delay_secs=None, is_internal=None, is_software_encryption_enabled=None, is_encrypted=None, affinity_host_ext_id=None, cluster_name=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__container_ext_id = None
        self.__owner_ext_id = None
        self.__name = None
        self.__cluster_ext_id = None
        self.__storage_pool_ext_id = None
        self.__is_marked_for_removal = None
        self.__max_capacity_bytes = None
        self.__logical_explicit_reserved_capacity_bytes = None
        self.__logical_implicit_reserved_capacity_bytes = None
        self.__logical_advertised_capacity_bytes = None
        self.__replication_factor = None
        self.__nfs_whitelist_address = None
        self.__is_nfs_whitelist_inherited = None
        self.__erasure_code = None
        self.__is_inline_ec_enabled = None
        self.__has_higher_ec_fault_domain_preference = None
        self.__erasure_code_delay_secs = None
        self.__cache_deduplication = None
        self.__on_disk_dedup = None
        self.__is_compression_enabled = None
        self.__compression_delay_secs = None
        self.__is_internal = None
        self.__is_software_encryption_enabled = None
        self.__is_encrypted = None
        self.__affinity_host_ext_id = None
        self.__cluster_name = None
        self.discriminator = None
        if container_ext_id is not None:
            self.__container_ext_id = container_ext_id
        if owner_ext_id is not None:
            self.__owner_ext_id = owner_ext_id
        self.__name = name
        if cluster_ext_id is not None:
            self.__cluster_ext_id = cluster_ext_id
        if storage_pool_ext_id is not None:
            self.__storage_pool_ext_id = storage_pool_ext_id
        if is_marked_for_removal is not None:
            self.__is_marked_for_removal = is_marked_for_removal
        if max_capacity_bytes is not None:
            self.__max_capacity_bytes = max_capacity_bytes
        if logical_explicit_reserved_capacity_bytes is not None:
            self.__logical_explicit_reserved_capacity_bytes = logical_explicit_reserved_capacity_bytes
        if logical_implicit_reserved_capacity_bytes is not None:
            self.__logical_implicit_reserved_capacity_bytes = logical_implicit_reserved_capacity_bytes
        if logical_advertised_capacity_bytes is not None:
            self.__logical_advertised_capacity_bytes = logical_advertised_capacity_bytes
        if replication_factor is not None:
            self.__replication_factor = replication_factor
        if nfs_whitelist_address is not None:
            self.__nfs_whitelist_address = nfs_whitelist_address
        if is_nfs_whitelist_inherited is not None:
            self.__is_nfs_whitelist_inherited = is_nfs_whitelist_inherited
        if erasure_code is not None:
            self.__erasure_code = erasure_code
        if is_inline_ec_enabled is not None:
            self.__is_inline_ec_enabled = is_inline_ec_enabled
        if has_higher_ec_fault_domain_preference is not None:
            self.__has_higher_ec_fault_domain_preference = has_higher_ec_fault_domain_preference
        if erasure_code_delay_secs is not None:
            self.__erasure_code_delay_secs = erasure_code_delay_secs
        if cache_deduplication is not None:
            self.__cache_deduplication = cache_deduplication
        if on_disk_dedup is not None:
            self.__on_disk_dedup = on_disk_dedup
        if is_compression_enabled is not None:
            self.__is_compression_enabled = is_compression_enabled
        if compression_delay_secs is not None:
            self.__compression_delay_secs = compression_delay_secs
        if is_internal is not None:
            self.__is_internal = is_internal
        if is_software_encryption_enabled is not None:
            self.__is_software_encryption_enabled = is_software_encryption_enabled
        if is_encrypted is not None:
            self.__is_encrypted = is_encrypted
        if affinity_host_ext_id is not None:
            self.__affinity_host_ext_id = affinity_host_ext_id
        if cluster_name is not None:
            self.__cluster_name = cluster_name

    def _initialize_object_type(self):
        return 'clustermgmt.v4.config.StorageContainer'

    def _initialize_object_version(self):
        return 'v4.r0'


    @property
    def container_ext_id(self):
        """
        The external identifier of the Storage Container.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__container_ext_id

    @container_ext_id.setter
    def container_ext_id(self, container_ext_id):
        if container_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', container_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `container_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__container_ext_id = container_ext_id

    @property
    def owner_ext_id(self):
        """
        The external identifier of the owner.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__owner_ext_id

    @owner_ext_id.setter
    def owner_ext_id(self, owner_ext_id):
        if owner_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', owner_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `owner_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__owner_ext_id = owner_ext_id

    @property
    def name(self):
        """
        Name of the Storage Container. Note that the name of Storage Container should be unique in every cluster.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__name

    @name.setter
    def name(self, name):
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")  # noqa: E501
        if name is not None and len(name) > 75:
            raise ValueError("Invalid value for `name`, length must be less than or equal to `75`")  # noqa: E501

        self.__name = name

    @property
    def cluster_ext_id(self):
        """
        The external identifier of the cluster owning the Storage Container.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__cluster_ext_id

    @cluster_ext_id.setter
    def cluster_ext_id(self, cluster_ext_id):
        if cluster_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', cluster_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `cluster_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__cluster_ext_id = cluster_ext_id

    @property
    def storage_pool_ext_id(self):
        """
        The external identifier  of the Storage Pool owning the Storage Container instance.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__storage_pool_ext_id

    @storage_pool_ext_id.setter
    def storage_pool_ext_id(self, storage_pool_ext_id):
        if storage_pool_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', storage_pool_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `storage_pool_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__storage_pool_ext_id = storage_pool_ext_id

    @property
    def is_marked_for_removal(self):
        """
        Indicates whether the Storage Container is marked for removal. This field is set when the Storage Container is about to be destroyed.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_marked_for_removal

    @is_marked_for_removal.setter
    def is_marked_for_removal(self, is_marked_for_removal):

        self.__is_marked_for_removal = is_marked_for_removal

    @property
    def max_capacity_bytes(self):
        """
        Maximum physical capacity of the Storage Container in bytes.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__max_capacity_bytes

    @max_capacity_bytes.setter
    def max_capacity_bytes(self, max_capacity_bytes):

        self.__max_capacity_bytes = max_capacity_bytes

    @property
    def logical_explicit_reserved_capacity_bytes(self):
        """
        Total reserved size (in bytes) of the Storage Container (set by Admin). This also includes the replication factor of the Storage Container. The actual reserved capacity of the Storage Container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__logical_explicit_reserved_capacity_bytes

    @logical_explicit_reserved_capacity_bytes.setter
    def logical_explicit_reserved_capacity_bytes(self, logical_explicit_reserved_capacity_bytes):

        self.__logical_explicit_reserved_capacity_bytes = logical_explicit_reserved_capacity_bytes

    @property
    def logical_implicit_reserved_capacity_bytes(self):
        """
        This is the sum of the  of reservations provisioned on all vDisks in the Storage Container. The actual reserved capacity of the Storage Container will be the maximum of explicitReservedCapacity and implicitReservedCapacity.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__logical_implicit_reserved_capacity_bytes

    @logical_implicit_reserved_capacity_bytes.setter
    def logical_implicit_reserved_capacity_bytes(self, logical_implicit_reserved_capacity_bytes):

        self.__logical_implicit_reserved_capacity_bytes = logical_implicit_reserved_capacity_bytes

    @property
    def logical_advertised_capacity_bytes(self):
        """
        Maximum capacity of the Storage Container as defined by the user.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__logical_advertised_capacity_bytes

    @logical_advertised_capacity_bytes.setter
    def logical_advertised_capacity_bytes(self, logical_advertised_capacity_bytes):

        self.__logical_advertised_capacity_bytes = logical_advertised_capacity_bytes

    @property
    def replication_factor(self):
        """
        Replication factor of the Storage Container.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__replication_factor

    @replication_factor.setter
    def replication_factor(self, replication_factor):

        self.__replication_factor = replication_factor

    @property
    def nfs_whitelist_address(self):
        """
        List of NFS addresses that need to be whitelisted.

        :type:
             list[ :class:`~ntnx_clustermgmt_py_client.models.common.v1.config.IPAddressOrFQDN` ]
        """  # noqa: E501
        return self.__nfs_whitelist_address

    @nfs_whitelist_address.setter
    def nfs_whitelist_address(self, nfs_whitelist_address):

        self.__nfs_whitelist_address = nfs_whitelist_address

    @property
    def is_nfs_whitelist_inherited(self):
        """
        Indicates whether the NFS whitelist is inherited from the global configuration.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_nfs_whitelist_inherited

    @is_nfs_whitelist_inherited.setter
    def is_nfs_whitelist_inherited(self, is_nfs_whitelist_inherited):

        self.__is_nfs_whitelist_inherited = is_nfs_whitelist_inherited

    @property
    def erasure_code(self):
        """
        

        :type:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.ErasureCodeStatus`
        """  # noqa: E501
        return self.__erasure_code

    @erasure_code.setter
    def erasure_code(self, erasure_code):

        self.__erasure_code = erasure_code

    @property
    def is_inline_ec_enabled(self):
        """
        Indicates whether data written to this Storage Container should be inline erasure-coded or not. This field is only considered if ErasureCoding is enabled.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_inline_ec_enabled

    @is_inline_ec_enabled.setter
    def is_inline_ec_enabled(self, is_inline_ec_enabled):

        self.__is_inline_ec_enabled = is_inline_ec_enabled

    @property
    def has_higher_ec_fault_domain_preference(self):
        """
        Indicates whether to prefer a higher Erasure Code fault domain.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__has_higher_ec_fault_domain_preference

    @has_higher_ec_fault_domain_preference.setter
    def has_higher_ec_fault_domain_preference(self, has_higher_ec_fault_domain_preference):

        self.__has_higher_ec_fault_domain_preference = has_higher_ec_fault_domain_preference

    @property
    def erasure_code_delay_secs(self):
        """
        Delay in performing Erasure Code for the current Storage Container instance.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__erasure_code_delay_secs

    @erasure_code_delay_secs.setter
    def erasure_code_delay_secs(self, erasure_code_delay_secs):

        self.__erasure_code_delay_secs = erasure_code_delay_secs

    @property
    def cache_deduplication(self):
        """
        

        :type:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.CacheDeduplication`
        """  # noqa: E501
        return self.__cache_deduplication

    @cache_deduplication.setter
    def cache_deduplication(self, cache_deduplication):

        self.__cache_deduplication = cache_deduplication

    @property
    def on_disk_dedup(self):
        """
        

        :type:
            :class:`~ntnx_clustermgmt_py_client.models.clustermgmt.v4.config.OnDiskDedup`
        """  # noqa: E501
        return self.__on_disk_dedup

    @on_disk_dedup.setter
    def on_disk_dedup(self, on_disk_dedup):

        self.__on_disk_dedup = on_disk_dedup

    @property
    def is_compression_enabled(self):
        """
        Indicates whether the compression is enabled for the Storage Container.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_compression_enabled

    @is_compression_enabled.setter
    def is_compression_enabled(self, is_compression_enabled):

        self.__is_compression_enabled = is_compression_enabled

    @property
    def compression_delay_secs(self):
        """
        The compression delay in seconds.

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__compression_delay_secs

    @compression_delay_secs.setter
    def compression_delay_secs(self, compression_delay_secs):

        self.__compression_delay_secs = compression_delay_secs

    @property
    def is_internal(self):
        """
        Indicates whether the Storage Container is internal and is managed by Nutanix.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_internal

    @is_internal.setter
    def is_internal(self, is_internal):

        self.__is_internal = is_internal

    @property
    def is_software_encryption_enabled(self):
        """
        Indicates whether the Storage Container instance has software encryption enabled.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_software_encryption_enabled

    @is_software_encryption_enabled.setter
    def is_software_encryption_enabled(self, is_software_encryption_enabled):

        self.__is_software_encryption_enabled = is_software_encryption_enabled

    @property
    def is_encrypted(self):
        """
        Indicates whether the Storage Container is encrypted or not.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__is_encrypted

    @is_encrypted.setter
    def is_encrypted(self, is_encrypted):

        self.__is_encrypted = is_encrypted

    @property
    def affinity_host_ext_id(self):
        """
        Affinity host external identifier for RF-1 Storage Container.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__affinity_host_ext_id

    @affinity_host_ext_id.setter
    def affinity_host_ext_id(self, affinity_host_ext_id):
        if affinity_host_ext_id is not None and not re.search('^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$', affinity_host_ext_id):  # noqa: E501
            raise ValueError(r"Invalid value for `affinity_host_ext_id`, must be a follow pattern or equal to `/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/`")  # noqa: E501

        self.__affinity_host_ext_id = affinity_host_ext_id

    @property
    def cluster_name(self):
        """
        The corresponding name of the cluster owning the Storage Container instance.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__cluster_name

    @cluster_name.setter
    def cluster_name(self, cluster_name):
        if cluster_name is not None and len(cluster_name) > 256:
            raise ValueError("Invalid value for `cluster_name`, length must be less than or equal to `256`")  # noqa: E501

        self.__cluster_name = cluster_name

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(StorageContainer, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, StorageContainer):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

