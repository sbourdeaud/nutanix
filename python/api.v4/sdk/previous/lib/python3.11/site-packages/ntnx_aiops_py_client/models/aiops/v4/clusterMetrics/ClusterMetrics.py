# coding: utf-8


"""
IGNORE:
    Nutanix AIOps APIs

    Manage infrastructure on-premises and in the cloud seamlessly through AIOps features such as Analysis, Reporting, Capacity Planning, What if Analysis, VM Rightsizing, Troubleshooting, App Discovery, Broad Observability, and Ops Automation through Playbooks.  # noqa: E501

    OpenAPI spec version: 4.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_aiops_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
from ntnx_aiops_py_client.models.common.v1.response.ApiLink import ApiLink  # noqa: F401,E501
from ntnx_aiops_py_client.models.common.v1.response.ExternalizableAbstractModel import ExternalizableAbstractModel  # noqa: F401,E501

class ClusterMetrics(ExternalizableAbstractModel):

    """

    :param cluster_name: (:attr:`cluster_name`) Name of the cluster
    :type cluster_name: 
    
    
    :param external_ip: (:attr:`external_ip`) 
    :type external_ip: 
    
    
    :param cvm_i_ps: (:attr:`cvm_i_ps`) CVM IPs of the nodes in the cluster
    :type cvm_i_ps: 
    
    
    :param total_memory_size_bytes: (:attr:`total_memory_size_bytes`) Total memory size in bytes in the cluster
    :type total_memory_size_bytes: 
    
    
    :param current_memory_usage_size_bytes: (:attr:`current_memory_usage_size_bytes`) Total memory size in bytes currently being used by the active VMs
    :type current_memory_usage_size_bytes: 
    
    
    :param provisioned_memory_usage_bytes: (:attr:`provisioned_memory_usage_bytes`) Total memory size in bytes provisioned for all the VMs
    :type provisioned_memory_usage_bytes: 
    
    
    :param max_vm_memory_size_bytes: (:attr:`max_vm_memory_size_bytes`) Largest possible memory size in bytes for the next VM that can be added
    :type max_vm_memory_size_bytes: 
    
    
    :param available_memory_size_bytes: (:attr:`available_memory_size_bytes`) Total amount of available memory in bytes for deploying new VMs
    :type available_memory_size_bytes: 
    
    
    :param largest_powered_off_vm_memory: (:attr:`largest_powered_off_vm_memory`) Powered OFF VM with the largest memory size
    :type largest_powered_off_vm_memory: 
    
    
    :param total_v_cpu_count: (:attr:`total_v_cpu_count`) Total number of vCPUs in the cluster
    :type total_v_cpu_count: 
    
    
    :param current_used_v_cpu_count: (:attr:`current_used_v_cpu_count`) Total number of vCPUs currently being used by the active VMs
    :type current_used_v_cpu_count: 
    
    
    :param provisioned_v_cpu_count: (:attr:`provisioned_v_cpu_count`) Total number of vCPUs provisioned for all the VMs
    :type provisioned_v_cpu_count: 
    
    
    :param max_vm_v_cpu_size: (:attr:`max_vm_v_cpu_size`) Largest possible VM size in vCPUs for the next VM that can be added
    :type max_vm_v_cpu_size: 
    
    
    :param available_v_cpu_count: (:attr:`available_v_cpu_count`) Total number of available VMs for deploying new VMs
    :type available_v_cpu_count: 
    
    
    :param largest_powered_off_vmv_cpu: (:attr:`largest_powered_off_vmv_cpu`) Largest powered OFF VM in terms of vCPU count
    :type largest_powered_off_vmv_cpu: 
    
    
    :param total_cpu_hz: (:attr:`total_cpu_hz`) Total amount of CPU in hertz in the cluster
    :type total_cpu_hz: 
    
    
    :param current_used_cpu_hz: (:attr:`current_used_cpu_hz`) Total amount of CPU in hertz currently being used by the active VMs
    :type current_used_cpu_hz: 
    
    
    :param provisioned_cpu_hz: (:attr:`provisioned_cpu_hz`) Total amount of CPU in hertz provisioned for all the VMs
    :type provisioned_cpu_hz: 
    
    
    :param total_storage_capacity_raw_bytes: (:attr:`total_storage_capacity_raw_bytes`) Total storage in bytes capacity in the cluster
    :type total_storage_capacity_raw_bytes: 
    
    
    :param total_storage_capacity_logical_bytes: (:attr:`total_storage_capacity_logical_bytes`) Total logical storage in bytes capacity after considering RF
    :type total_storage_capacity_logical_bytes: 
    
    
    :param total_storage_capacity_logical_with_savings_bytes: (:attr:`total_storage_capacity_logical_with_savings_bytes`) Total logical storage capacity in bytes after accounting for savings from dedup, compressions,and erasure coding
    :type total_storage_capacity_logical_with_savings_bytes: 
    
    
    :param total_storage_usage_bytes: (:attr:`total_storage_usage_bytes`) Total raw storage usage by the cluster
    :type total_storage_usage_bytes: 
    
    
    :param total_storage_available_bytes: (:attr:`total_storage_available_bytes`) Total raw storage bytes still available in the cluster
    :type total_storage_available_bytes: 
    
    
    :param total_storage_available_logical_bytes: (:attr:`total_storage_available_logical_bytes`) Total logical storage bytes still available in the cluster
    :type total_storage_available_logical_bytes: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'cluster_name': 'str',
        'external_ip': 'common.v1.config.IPv4Address',
        'cvm_i_ps': 'list[common.v1.config.IPv4Address]',
        'total_memory_size_bytes': 'int',
        'current_memory_usage_size_bytes': 'int',
        'provisioned_memory_usage_bytes': 'int',
        'max_vm_memory_size_bytes': 'int',
        'available_memory_size_bytes': 'int',
        'largest_powered_off_vm_memory': 'int',
        'total_v_cpu_count': 'int',
        'current_used_v_cpu_count': 'int',
        'provisioned_v_cpu_count': 'int',
        'max_vm_v_cpu_size': 'int',
        'available_v_cpu_count': 'int',
        'largest_powered_off_vmv_cpu': 'int',
        'total_cpu_hz': 'int',
        'current_used_cpu_hz': 'int',
        'provisioned_cpu_hz': 'int',
        'total_storage_capacity_raw_bytes': 'int',
        'total_storage_capacity_logical_bytes': 'int',
        'total_storage_capacity_logical_with_savings_bytes': 'int',
        'total_storage_usage_bytes': 'int',
        'total_storage_available_bytes': 'int',
        'total_storage_available_logical_bytes': 'int',
        'ext_id': 'str',
        'links': 'list[common.v1.response.ApiLink]',
        'tenant_id': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'cluster_name': 'clusterName',
        'external_ip': 'externalIP',
        'cvm_i_ps': 'cvmIPs',
        'total_memory_size_bytes': 'totalMemorySizeBytes',
        'current_memory_usage_size_bytes': 'currentMemoryUsageSizeBytes',
        'provisioned_memory_usage_bytes': 'provisionedMemoryUsageBytes',
        'max_vm_memory_size_bytes': 'maxVmMemorySizeBytes',
        'available_memory_size_bytes': 'availableMemorySizeBytes',
        'largest_powered_off_vm_memory': 'largestPoweredOffVMMemory',
        'total_v_cpu_count': 'totalVCpuCount',
        'current_used_v_cpu_count': 'currentUsedVCpuCount',
        'provisioned_v_cpu_count': 'provisionedVCpuCount',
        'max_vm_v_cpu_size': 'maxVmVCpuSize',
        'available_v_cpu_count': 'availableVCpuCount',
        'largest_powered_off_vmv_cpu': 'largestPoweredOffVMVCpu',
        'total_cpu_hz': 'totalCpuHz',
        'current_used_cpu_hz': 'currentUsedCpuHz',
        'provisioned_cpu_hz': 'provisionedCpuHz',
        'total_storage_capacity_raw_bytes': 'totalStorageCapacityRawBytes',
        'total_storage_capacity_logical_bytes': 'totalStorageCapacityLogicalBytes',
        'total_storage_capacity_logical_with_savings_bytes': 'totalStorageCapacityLogicalWithSavingsBytes',
        'total_storage_usage_bytes': 'totalStorageUsageBytes',
        'total_storage_available_bytes': 'totalStorageAvailableBytes',
        'total_storage_available_logical_bytes': 'totalStorageAvailableLogicalBytes',
        'ext_id': 'extId',
        'links': 'links',
        'tenant_id': 'tenantId',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, cluster_name=None, external_ip=None, cvm_i_ps=None, total_memory_size_bytes=None, current_memory_usage_size_bytes=None, provisioned_memory_usage_bytes=None, max_vm_memory_size_bytes=None, available_memory_size_bytes=None, largest_powered_off_vm_memory=None, total_v_cpu_count=None, current_used_v_cpu_count=None, provisioned_v_cpu_count=None, max_vm_v_cpu_size=None, available_v_cpu_count=None, largest_powered_off_vmv_cpu=None, total_cpu_hz=None, current_used_cpu_hz=None, provisioned_cpu_hz=None, total_storage_capacity_raw_bytes=None, total_storage_capacity_logical_bytes=None, total_storage_capacity_logical_with_savings_bytes=None, total_storage_usage_bytes=None, total_storage_available_bytes=None, total_storage_available_logical_bytes=None, ext_id=None, links=None, tenant_id=None, *args, **kwargs):  # noqa: E501
        ExternalizableAbstractModel.__init__(self, ext_id, links, tenant_id, *args, **kwargs)
        self.__cluster_name = None
        self.__external_ip = None
        self.__cvm_i_ps = None
        self.__total_memory_size_bytes = None
        self.__current_memory_usage_size_bytes = None
        self.__provisioned_memory_usage_bytes = None
        self.__max_vm_memory_size_bytes = None
        self.__available_memory_size_bytes = None
        self.__largest_powered_off_vm_memory = None
        self.__total_v_cpu_count = None
        self.__current_used_v_cpu_count = None
        self.__provisioned_v_cpu_count = None
        self.__max_vm_v_cpu_size = None
        self.__available_v_cpu_count = None
        self.__largest_powered_off_vmv_cpu = None
        self.__total_cpu_hz = None
        self.__current_used_cpu_hz = None
        self.__provisioned_cpu_hz = None
        self.__total_storage_capacity_raw_bytes = None
        self.__total_storage_capacity_logical_bytes = None
        self.__total_storage_capacity_logical_with_savings_bytes = None
        self.__total_storage_usage_bytes = None
        self.__total_storage_available_bytes = None
        self.__total_storage_available_logical_bytes = None
        self.discriminator = None
        if cluster_name is not None:
            self.__cluster_name = cluster_name
        if external_ip is not None:
            self.__external_ip = external_ip
        if cvm_i_ps is not None:
            self.__cvm_i_ps = cvm_i_ps
        if total_memory_size_bytes is not None:
            self.__total_memory_size_bytes = total_memory_size_bytes
        if current_memory_usage_size_bytes is not None:
            self.__current_memory_usage_size_bytes = current_memory_usage_size_bytes
        if provisioned_memory_usage_bytes is not None:
            self.__provisioned_memory_usage_bytes = provisioned_memory_usage_bytes
        if max_vm_memory_size_bytes is not None:
            self.__max_vm_memory_size_bytes = max_vm_memory_size_bytes
        if available_memory_size_bytes is not None:
            self.__available_memory_size_bytes = available_memory_size_bytes
        if largest_powered_off_vm_memory is not None:
            self.__largest_powered_off_vm_memory = largest_powered_off_vm_memory
        if total_v_cpu_count is not None:
            self.__total_v_cpu_count = total_v_cpu_count
        if current_used_v_cpu_count is not None:
            self.__current_used_v_cpu_count = current_used_v_cpu_count
        if provisioned_v_cpu_count is not None:
            self.__provisioned_v_cpu_count = provisioned_v_cpu_count
        if max_vm_v_cpu_size is not None:
            self.__max_vm_v_cpu_size = max_vm_v_cpu_size
        if available_v_cpu_count is not None:
            self.__available_v_cpu_count = available_v_cpu_count
        if largest_powered_off_vmv_cpu is not None:
            self.__largest_powered_off_vmv_cpu = largest_powered_off_vmv_cpu
        if total_cpu_hz is not None:
            self.__total_cpu_hz = total_cpu_hz
        if current_used_cpu_hz is not None:
            self.__current_used_cpu_hz = current_used_cpu_hz
        if provisioned_cpu_hz is not None:
            self.__provisioned_cpu_hz = provisioned_cpu_hz
        if total_storage_capacity_raw_bytes is not None:
            self.__total_storage_capacity_raw_bytes = total_storage_capacity_raw_bytes
        if total_storage_capacity_logical_bytes is not None:
            self.__total_storage_capacity_logical_bytes = total_storage_capacity_logical_bytes
        if total_storage_capacity_logical_with_savings_bytes is not None:
            self.__total_storage_capacity_logical_with_savings_bytes = total_storage_capacity_logical_with_savings_bytes
        if total_storage_usage_bytes is not None:
            self.__total_storage_usage_bytes = total_storage_usage_bytes
        if total_storage_available_bytes is not None:
            self.__total_storage_available_bytes = total_storage_available_bytes
        if total_storage_available_logical_bytes is not None:
            self.__total_storage_available_logical_bytes = total_storage_available_logical_bytes

    def _initialize_object_type(self):
        return 'aiops.v4.clusterMetrics.ClusterMetrics'

    def _initialize_object_version(self):
        return 'v4.r0'


    @property
    def cluster_name(self):
        """
        Name of the cluster

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__cluster_name

    @cluster_name.setter
    def cluster_name(self, cluster_name):

        self.__cluster_name = cluster_name

    @property
    def external_ip(self):
        """
        

        :type:
            :class:`~ntnx_aiops_py_client.models.common.v1.config.IPv4Address`
        """  # noqa: E501
        return self.__external_ip

    @external_ip.setter
    def external_ip(self, external_ip):

        self.__external_ip = external_ip

    @property
    def cvm_i_ps(self):
        """
        CVM IPs of the nodes in the cluster

        :type:
             list[ :class:`~ntnx_aiops_py_client.models.common.v1.config.IPv4Address` ]
        """  # noqa: E501
        return self.__cvm_i_ps

    @cvm_i_ps.setter
    def cvm_i_ps(self, cvm_i_ps):

        self.__cvm_i_ps = cvm_i_ps

    @property
    def total_memory_size_bytes(self):
        """
        Total memory size in bytes in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_memory_size_bytes

    @total_memory_size_bytes.setter
    def total_memory_size_bytes(self, total_memory_size_bytes):

        self.__total_memory_size_bytes = total_memory_size_bytes

    @property
    def current_memory_usage_size_bytes(self):
        """
        Total memory size in bytes currently being used by the active VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__current_memory_usage_size_bytes

    @current_memory_usage_size_bytes.setter
    def current_memory_usage_size_bytes(self, current_memory_usage_size_bytes):

        self.__current_memory_usage_size_bytes = current_memory_usage_size_bytes

    @property
    def provisioned_memory_usage_bytes(self):
        """
        Total memory size in bytes provisioned for all the VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__provisioned_memory_usage_bytes

    @provisioned_memory_usage_bytes.setter
    def provisioned_memory_usage_bytes(self, provisioned_memory_usage_bytes):

        self.__provisioned_memory_usage_bytes = provisioned_memory_usage_bytes

    @property
    def max_vm_memory_size_bytes(self):
        """
        Largest possible memory size in bytes for the next VM that can be added

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__max_vm_memory_size_bytes

    @max_vm_memory_size_bytes.setter
    def max_vm_memory_size_bytes(self, max_vm_memory_size_bytes):

        self.__max_vm_memory_size_bytes = max_vm_memory_size_bytes

    @property
    def available_memory_size_bytes(self):
        """
        Total amount of available memory in bytes for deploying new VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__available_memory_size_bytes

    @available_memory_size_bytes.setter
    def available_memory_size_bytes(self, available_memory_size_bytes):

        self.__available_memory_size_bytes = available_memory_size_bytes

    @property
    def largest_powered_off_vm_memory(self):
        """
        Powered OFF VM with the largest memory size

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__largest_powered_off_vm_memory

    @largest_powered_off_vm_memory.setter
    def largest_powered_off_vm_memory(self, largest_powered_off_vm_memory):

        self.__largest_powered_off_vm_memory = largest_powered_off_vm_memory

    @property
    def total_v_cpu_count(self):
        """
        Total number of vCPUs in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_v_cpu_count

    @total_v_cpu_count.setter
    def total_v_cpu_count(self, total_v_cpu_count):

        self.__total_v_cpu_count = total_v_cpu_count

    @property
    def current_used_v_cpu_count(self):
        """
        Total number of vCPUs currently being used by the active VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__current_used_v_cpu_count

    @current_used_v_cpu_count.setter
    def current_used_v_cpu_count(self, current_used_v_cpu_count):

        self.__current_used_v_cpu_count = current_used_v_cpu_count

    @property
    def provisioned_v_cpu_count(self):
        """
        Total number of vCPUs provisioned for all the VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__provisioned_v_cpu_count

    @provisioned_v_cpu_count.setter
    def provisioned_v_cpu_count(self, provisioned_v_cpu_count):

        self.__provisioned_v_cpu_count = provisioned_v_cpu_count

    @property
    def max_vm_v_cpu_size(self):
        """
        Largest possible VM size in vCPUs for the next VM that can be added

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__max_vm_v_cpu_size

    @max_vm_v_cpu_size.setter
    def max_vm_v_cpu_size(self, max_vm_v_cpu_size):

        self.__max_vm_v_cpu_size = max_vm_v_cpu_size

    @property
    def available_v_cpu_count(self):
        """
        Total number of available VMs for deploying new VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__available_v_cpu_count

    @available_v_cpu_count.setter
    def available_v_cpu_count(self, available_v_cpu_count):

        self.__available_v_cpu_count = available_v_cpu_count

    @property
    def largest_powered_off_vmv_cpu(self):
        """
        Largest powered OFF VM in terms of vCPU count

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__largest_powered_off_vmv_cpu

    @largest_powered_off_vmv_cpu.setter
    def largest_powered_off_vmv_cpu(self, largest_powered_off_vmv_cpu):

        self.__largest_powered_off_vmv_cpu = largest_powered_off_vmv_cpu

    @property
    def total_cpu_hz(self):
        """
        Total amount of CPU in hertz in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_cpu_hz

    @total_cpu_hz.setter
    def total_cpu_hz(self, total_cpu_hz):

        self.__total_cpu_hz = total_cpu_hz

    @property
    def current_used_cpu_hz(self):
        """
        Total amount of CPU in hertz currently being used by the active VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__current_used_cpu_hz

    @current_used_cpu_hz.setter
    def current_used_cpu_hz(self, current_used_cpu_hz):

        self.__current_used_cpu_hz = current_used_cpu_hz

    @property
    def provisioned_cpu_hz(self):
        """
        Total amount of CPU in hertz provisioned for all the VMs

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__provisioned_cpu_hz

    @provisioned_cpu_hz.setter
    def provisioned_cpu_hz(self, provisioned_cpu_hz):

        self.__provisioned_cpu_hz = provisioned_cpu_hz

    @property
    def total_storage_capacity_raw_bytes(self):
        """
        Total storage in bytes capacity in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_capacity_raw_bytes

    @total_storage_capacity_raw_bytes.setter
    def total_storage_capacity_raw_bytes(self, total_storage_capacity_raw_bytes):

        self.__total_storage_capacity_raw_bytes = total_storage_capacity_raw_bytes

    @property
    def total_storage_capacity_logical_bytes(self):
        """
        Total logical storage in bytes capacity after considering RF

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_capacity_logical_bytes

    @total_storage_capacity_logical_bytes.setter
    def total_storage_capacity_logical_bytes(self, total_storage_capacity_logical_bytes):

        self.__total_storage_capacity_logical_bytes = total_storage_capacity_logical_bytes

    @property
    def total_storage_capacity_logical_with_savings_bytes(self):
        """
        Total logical storage capacity in bytes after accounting for savings from dedup, compressions,and erasure coding

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_capacity_logical_with_savings_bytes

    @total_storage_capacity_logical_with_savings_bytes.setter
    def total_storage_capacity_logical_with_savings_bytes(self, total_storage_capacity_logical_with_savings_bytes):

        self.__total_storage_capacity_logical_with_savings_bytes = total_storage_capacity_logical_with_savings_bytes

    @property
    def total_storage_usage_bytes(self):
        """
        Total raw storage usage by the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_usage_bytes

    @total_storage_usage_bytes.setter
    def total_storage_usage_bytes(self, total_storage_usage_bytes):

        self.__total_storage_usage_bytes = total_storage_usage_bytes

    @property
    def total_storage_available_bytes(self):
        """
        Total raw storage bytes still available in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_available_bytes

    @total_storage_available_bytes.setter
    def total_storage_available_bytes(self, total_storage_available_bytes):

        self.__total_storage_available_bytes = total_storage_available_bytes

    @property
    def total_storage_available_logical_bytes(self):
        """
        Total logical storage bytes still available in the cluster

        :type:
                :class:`~int`
        """  # noqa: E501
        return self.__total_storage_available_logical_bytes

    @total_storage_available_logical_bytes.setter
    def total_storage_available_logical_bytes(self, total_storage_available_logical_bytes):

        self.__total_storage_available_logical_bytes = total_storage_available_logical_bytes

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(ClusterMetrics, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ClusterMetrics):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

