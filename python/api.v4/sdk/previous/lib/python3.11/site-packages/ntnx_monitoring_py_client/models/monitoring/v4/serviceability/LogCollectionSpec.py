# coding: utf-8


"""
IGNORE:
    Nutanix Monitoring APIs

    Manage Alerts, Alert policies, Events and Audits  # noqa: E501

    OpenAPI spec version: 4.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
IGNORE
"""
import pprint
import json
import ast
import re  # noqa: F401

import six
from pathlib import Path
from ntnx_monitoring_py_client.models.common.v1.config.IPv4Address import IPv4Address  # noqa: F401,E501
from ntnx_monitoring_py_client.models.monitoring.v4.serviceability.ArchiveOpts import ArchiveOpts  # noqa: F401,E501

class LogCollectionSpec(object):

    """Input parameters for collecting logs.

    :param start_time: (:attr:`start_time`) The time marking the start of a log collection window. It should be in the following format:  YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS+HH:MM or YYYY-MM-DDTHH:MM:SS-HH:MM. The start time of log collection should be within the past three months. For example: - 1985-04-12T23:20:50.52Z represents 20 minutes and 50.52 seconds after the 23rd hour of   April 12th, 1985 in UTC. - 1996-12-19T16:39:57-08:00 represents 39 minutes and 57 seconds after the 16th hour   of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).   Note that this is equivalent to 1996-12-20T00:39:57Z in UTC. 
    :type start_time: required
    
    
    :param end_time: (:attr:`end_time`) The time marking the end of a log collection window. It should be in the following format:  YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS+HH:MM or YYYY-MM-DDTHH:MM:SS-HH:MM. The end time of log collection should be within the past three months. For example: - 1985-04-12T23:20:50.52Z represents 20 minutes and 50.52 seconds after the 23rd hour of   April 12th, 1985 in UTC. - 1996-12-19T16:39:57-08:00 represents 39 minutes and 57 seconds after the 16th hour   of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).   Note that this is equivalent to 1996-12-20T00:39:57Z in UTC. 
    :type end_time: required
    
    
    :param include_tags: (:attr:`include_tags`) Collect items associated with the tag IDs. The tag ID can be fetched from the GET tags operation. If no tags are specified, all items will be collected by default, which will take a longer time. It is recommended that at least one tag is selected. 
    :type include_tags: 
    
    
    :param should_anonymize: (:attr:`should_anonymize`) Indicates whether to mask sensitive data in the collected logs or not. (**Default** False)
    :type should_anonymize: 
    
    
    :param node_ip_list: (:attr:`node_ip_list`) List of node IP addresses from where the logs will be collected.
    :type node_ip_list: 
    
    
    :param should_collect_from_disabled_node: (:attr:`should_collect_from_disabled_node`) Indicates whether to collect logs from a node where services are down or not. This feature is not supported on PC. (**Default** False)
    :type should_collect_from_disabled_node: 
    
    
    :param exclude_tags: (:attr:`exclude_tags`) Exclude items associated with the tag IDs. The tag ID can be fetched from the GET tags operation.
    :type exclude_tags: 
    
    
    :param archive_opts: (:attr:`archive_opts`) 
    :type archive_opts: required
    
    
    :param description: (:attr:`description`) Description to be attached with the associated log collection task. (**Default** 'Log collection via V4 API')
    :type description: 
    
    

    """
    """
    IGNORE:
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    IGNORE
    """  # noqa: E501
    swagger_types = {
        'start_time': 'datetime',
        'end_time': 'datetime',
        'include_tags': 'list[str]',
        'should_anonymize': 'bool',
        'node_ip_list': 'list[common.v1.config.IPv4Address]',
        'should_collect_from_disabled_node': 'bool',
        'exclude_tags': 'list[str]',
        'archive_opts': 'monitoring.v4.serviceability.ArchiveOpts',
        'description': 'str',
        '_reserved': 'dict(str, object)',
        '_object_type': 'str',
        '_unknown_fields': 'dict(str, object)',
    }

    attribute_map = {
        'start_time': 'startTime',
        'end_time': 'endTime',
        'include_tags': 'includeTags',
        'should_anonymize': 'shouldAnonymize',
        'node_ip_list': 'nodeIpList',
        'should_collect_from_disabled_node': 'shouldCollectFromDisabledNode',
        'exclude_tags': 'excludeTags',
        'archive_opts': 'archiveOpts',
        'description': 'description',
        '_reserved': '$reserved',
        '_object_type': '$objectType',
        '_unknown_fields': '$unknownFields',
    }



    def __init__(self, start_time=None, end_time=None, include_tags=None, should_anonymize=False, node_ip_list=None, should_collect_from_disabled_node=False, exclude_tags=None, archive_opts=None, description='Log collection via V4 API', *args, **kwargs):  # noqa: E501
        self.__start_time = None
        self.__end_time = None
        self.__include_tags = None
        self.__should_anonymize = None
        self.__node_ip_list = None
        self.__should_collect_from_disabled_node = None
        self.__exclude_tags = None
        self.__archive_opts = None
        self.__description = None
        self.discriminator = None
        self.__start_time = start_time
        self.__end_time = end_time
        if include_tags is not None:
            self.__include_tags = include_tags
        if should_anonymize is not None:
            self.__should_anonymize = should_anonymize
        if node_ip_list is not None:
            self.__node_ip_list = node_ip_list
        if should_collect_from_disabled_node is not None:
            self.__should_collect_from_disabled_node = should_collect_from_disabled_node
        if exclude_tags is not None:
            self.__exclude_tags = exclude_tags
        self.__archive_opts = archive_opts
        if description is not None:
            self.__description = description
        # populate hidden vars if not empty
        self._populate_hidden_vars(kwargs)

    def _initialize_object_type(self):
        return 'monitoring.v4.serviceability.LogCollectionSpec'

    def _initialize_object_version(self):
        return 'v4.r0'

    def _populate_hidden_vars(self, kwargs):
        if "_reserved" in kwargs and kwargs["_reserved"] is not None:
            self.__dollar_reserved = kwargs["_reserved"]
        elif hasattr(self, "attribute_map") and "_reserved" in self.attribute_map and self.attribute_map["_reserved"] in kwargs and kwargs[self.attribute_map["_reserved"]] is not None:
            self.__dollar_reserved = kwargs[self.attribute_map["_reserved"]]
        else :
            self.__dollar_reserved = {"$fv": self._initialize_object_version()}
        if "_unknown_fields" in kwargs and kwargs["_unknown_fields"] is not None:
            self.__dollar_unknown_fields = kwargs["_unknown_fields"]
        elif hasattr(self, "attribute_map") and "_unknown_fields" in self.attribute_map and self.attribute_map["_unknown_fields"] in kwargs and kwargs[self.attribute_map["_unknown_fields"]] is not None:
            self.__dollar_unknown_fields = kwargs[self.attribute_map["_unknown_fields"]]
        else :
            self.__dollar_unknown_fields = {}
        if "_object_type" in kwargs and kwargs["_object_type"] is not None:
            self.__dollar_object_type = kwargs["_object_type"]
        elif hasattr(self, "attribute_map") and "_object_type" in self.attribute_map and self.attribute_map["_object_type"] in kwargs and kwargs[self.attribute_map["_object_type"]] is not None:
            self.__dollar_object_type = kwargs[self.attribute_map["_object_type"]]
        else:
            self.__dollar_object_type = self._initialize_object_type()

    def get_object_type(self):
        return self.__dollar_object_type

    def get_reserved(self):
        return self.__dollar_reserved

    def get_unknown_fields(self):
        return self.__dollar_unknown_fields

    @property
    def start_time(self):
        """
        The time marking the start of a log collection window. It should be in the following format:  YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS+HH:MM or YYYY-MM-DDTHH:MM:SS-HH:MM. The start time of log collection should be within the past three months. For example: - 1985-04-12T23:20:50.52Z represents 20 minutes and 50.52 seconds after the 23rd hour of   April 12th, 1985 in UTC. - 1996-12-19T16:39:57-08:00 represents 39 minutes and 57 seconds after the 16th hour   of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).   Note that this is equivalent to 1996-12-20T00:39:57Z in UTC. 

        :type:
                :class:`~datetime`
        """  # noqa: E501
        return self.__start_time

    @start_time.setter
    def start_time(self, start_time):
        if start_time is None:
            raise ValueError("Invalid value for `start_time`, must not be `None`")  # noqa: E501

        self.__start_time = start_time

    @property
    def end_time(self):
        """
        The time marking the end of a log collection window. It should be in the following format:  YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS+HH:MM or YYYY-MM-DDTHH:MM:SS-HH:MM. The end time of log collection should be within the past three months. For example: - 1985-04-12T23:20:50.52Z represents 20 minutes and 50.52 seconds after the 23rd hour of   April 12th, 1985 in UTC. - 1996-12-19T16:39:57-08:00 represents 39 minutes and 57 seconds after the 16th hour   of December 19th, 1996 with an offset of -08:00 from UTC (Pacific Standard Time).   Note that this is equivalent to 1996-12-20T00:39:57Z in UTC. 

        :type:
                :class:`~datetime`
        """  # noqa: E501
        return self.__end_time

    @end_time.setter
    def end_time(self, end_time):
        if end_time is None:
            raise ValueError("Invalid value for `end_time`, must not be `None`")  # noqa: E501

        self.__end_time = end_time

    @property
    def include_tags(self):
        """
        Collect items associated with the tag IDs. The tag ID can be fetched from the GET tags operation. If no tags are specified, all items will be collected by default, which will take a longer time. It is recommended that at least one tag is selected. 

        :type:
            list[ :class:`~str` ]
        """  # noqa: E501
        return self.__include_tags

    @include_tags.setter
    def include_tags(self, include_tags):

        self.__include_tags = include_tags

    @property
    def should_anonymize(self):
        """
        Indicates whether to mask sensitive data in the collected logs or not.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_anonymize

    @should_anonymize.setter
    def should_anonymize(self, should_anonymize):

        self.__should_anonymize = should_anonymize

    @property
    def node_ip_list(self):
        """
        List of node IP addresses from where the logs will be collected.

        :type:
             list[ :class:`~ntnx_monitoring_py_client.models.common.v1.config.IPv4Address` ]
        """  # noqa: E501
        return self.__node_ip_list

    @node_ip_list.setter
    def node_ip_list(self, node_ip_list):

        self.__node_ip_list = node_ip_list

    @property
    def should_collect_from_disabled_node(self):
        """
        Indicates whether to collect logs from a node where services are down or not. This feature is not supported on PC.

        :type:
                :class:`~bool`
        """  # noqa: E501
        return self.__should_collect_from_disabled_node

    @should_collect_from_disabled_node.setter
    def should_collect_from_disabled_node(self, should_collect_from_disabled_node):

        self.__should_collect_from_disabled_node = should_collect_from_disabled_node

    @property
    def exclude_tags(self):
        """
        Exclude items associated with the tag IDs. The tag ID can be fetched from the GET tags operation.

        :type:
            list[ :class:`~str` ]
        """  # noqa: E501
        return self.__exclude_tags

    @exclude_tags.setter
    def exclude_tags(self, exclude_tags):

        self.__exclude_tags = exclude_tags

    @property
    def archive_opts(self):
        """
        

        :type:
            :class:`~ntnx_monitoring_py_client.models.monitoring.v4.serviceability.ArchiveOpts`
        """  # noqa: E501
        return self.__archive_opts

    @archive_opts.setter
    def archive_opts(self, archive_opts):
        if archive_opts is None:
            raise ValueError("Invalid value for `archive_opts`, must not be `None`")  # noqa: E501

        self.__archive_opts = archive_opts

    @property
    def description(self):
        """
        Description to be attached with the associated log collection task.

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__description

    @description.setter
    def description(self, description):

        self.__description = description

    @property
    def _reserved(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_reserved

    @property
    def _object_type(self):
        """
        

        :type:
                :class:`~str`
        """  # noqa: E501
        return self.__dollar_object_type

    @property
    def _unknown_fields(self):
        """
        

        :type:
            dict(str, :class:`~object`)
        """  # noqa: E501
        return self.__dollar_unknown_fields

    def _to_dict(self, sanitize):
        """Returns the model properties as a dict. Omits None properties based on the provided "sanitize" parameter.

        :param sanitize: A flag to omit None properties if set to True
        :type sanitize: bool
        """

        result = {}
        for attr, attr_type in six.iteritems(self.swagger_types):

            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x._to_dict(sanitize) if hasattr(x, "_to_dict") else x,
                    value
                ))
            elif hasattr(value, "_to_dict"):
                result[attr] = value._to_dict(sanitize)
            elif isinstance(value, Path):
                result[attr] = str(value)
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1]._to_dict(sanitize)) if hasattr(item[1], "_to_dict")
                    else (
                        (item[0], str(item[1])) if item[0] == 'path' and '$objectType' in value and value['$objectType'] == 'pathlib.Path'
                        else item
                    ),
                    six.iteritems(value)
                ))
            else:
                if sanitize:
                    if value is not None:
                        result[attr] = value
                else:
                    result[attr] = value
        if issubclass(LogCollectionSpec, dict):
            for key, value in six.iteritems(self):
                result[key] = value

        return result

    def to_dict(self):
        """Returns the model properties as a dictionary"""
        return self._to_dict(False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self._to_dict(True))

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, LogCollectionSpec):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other

